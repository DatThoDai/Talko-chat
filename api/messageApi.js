import api from './axios';
import { API_ENDPOINTS } from '../constants';
import { Platform } from 'react-native'; // Th√™m d√≤ng n√†y

// ƒê·ªìng b·ªô v·ªõi conversationApi, s·ª≠ d·ª•ng endpoint chu·∫©n
const BASE_URL = API_ENDPOINTS.MESSAGES;

console.log('Using messages endpoint:', BASE_URL);

// T·∫°o messageApi object ƒë·ªÉ export ·ªü cu·ªëi file
const messageApi = {
  fetchMessage: (conversationId, params) => {
    try {
      console.log('Fetching messages for conversation:', conversationId);
      const url = `${BASE_URL}/${conversationId}`;
      return api.get(url, {params});
    } catch (error) {
      console.error('Error fetching messages:', error.message);
      return { data: [] }; // Tr·∫£ v·ªÅ m·∫£ng r·ªóng ƒë·ªÉ tr√°nh crash
    }
  },
  fetchFiles: (conversationId, params) => {
    const url = `${BASE_URL}/${conversationId}/files`;
    return api.get(url, {params});
  },

  sendMessage: message => {
    try {
      
      // CH·ª¶ QUAN TR·ªåNG: Endpoint ph·∫£i l√† /messages/text (kh√¥ng ph·∫£i /messages)
      const endpoint = '/messages/text';
      
      // Y√äU C·∫¶U 1: Ph·∫£i g·ª≠i JSON object v·ªõi ƒë√∫ng c√°c tr∆∞·ªùng:
      // - type: ph·∫£i l√† "TEXT" ho√†n to√†n vi·∫øt hoa
      // - conversationId: ID cu·ªôc tr√≤ chuy·ªán
      // - content: n·ªôi dung tin nh·∫Øn
      
      // B∆∞·ªõc 1: T·∫°o object ho√†n to√†n m·ªõi, kh√¥ng s·ª≠ d·ª•ng l·∫°i object c≈©
      const requestBody = {};
      
      // B∆∞·ªõc 2: G√°n tr·ª±c ti·∫øp c√°c gi√° tr·ªã (kh√¥ng th√¥ng qua bi·∫øn)
      requestBody.conversationId = message.conversationId;
      requestBody.content = message.content;
      // ƒê·∫£m b·∫£o ƒë√∫ng ƒë·ªãnh d·∫°ng type cho backend
      requestBody.type = "TEXT"; // QUAN TR·ªåNG: Ph·∫£i l√† string hardcode v√† vi·∫øt hoa
      
      // B∆∞·ªõc 3: Th√™m tr∆∞·ªùng replyMessageId n·∫øu c√≥
      if (message.replyMessageId) {
        requestBody.replyMessageId = message.replyMessageId;
      }

      // B∆∞·ªõc 4: Th√™m tr∆∞·ªùng forwardedMessage n·∫øu c√≥
      if (message.forwardedMessage) {
        requestBody.metadata = {
          isForwarded: true,
          forwardedAt: new Date()
        };
      }
      
      // B∆∞·ªõc 5: Log chi ti·∫øt truy·ªÅn g·ª≠i ƒë·ªÉ debug
      console.log(`Sending message to ${endpoint} with data:`, JSON.stringify(requestBody, null, 2));

      // B∆∞·ªõc 6: G·ªçi API v·ªõi c√°c header v√† config chu·∫©n
      return api.post(endpoint, requestBody, {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      });
    } catch (error) {
      // Log l·ªói ƒë·∫ßy ƒë·ªß cho debugging
      console.error('Failed to send message:', error?.message || 'Unknown error');
      
      if (error?.response) {
        console.error(`Server responded with status ${error.response.status}:`, 
          JSON.stringify(error.response.data || {}, null, 2));
      }
      
      // Re-throw error ƒë·ªÉ component c√≥ th·ªÉ x·ª≠ l√Ω
      throw error;
    }
  },
  // X√≥a tin nh·∫Øn (ch·ªâ ·ªü phi√™n b·∫£n c·ªßa m√¨nh) - t∆∞∆°ng ƒë∆∞∆°ng v·ªõi deleteMessageClientSide trong web
  deleteMessage: messageId => {
    console.log('Deleting message client side:', messageId);
    const url = `${BASE_URL}/${messageId}/only`;
    return api.delete(url);
  },
  
  // Gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c
  deleteMessageOnlyMe: messageId => {
    console.log('Using deleteMessage for deleteMessageOnlyMe - client side only');
    return messageApi.deleteMessage(messageId);
  },
  addReaction: (messageId, type) => {
    const url = `${BASE_URL}/${messageId}/reacts/${type}`;
    return api.post(url);
  },

  sendFileBase64Message: (file, params, uploadProgress) => {
    try {
      const {type, conversationId, channelId} = params;
      console.log('Uploading file to conversation:', conversationId, 'with type:', type);

      const config = {
        params: {
          type,
          conversationId,
          channelId,
        },

        onUploadProgress: progressEvent => {
          if (typeof uploadProgress === 'function') {
            let percentCompleted = Math.round(
              (progressEvent.loaded * 100) / progressEvent.total,
            );
            uploadProgress(percentCompleted);
            
            // Log ti·∫øn ƒë·ªô upload ƒë·ªÉ debug
            if (percentCompleted % 20 === 0) { // Log m·ªói 20%
              console.log(`File upload progress: ${percentCompleted}%`);
            }
          }
        },
      };

      // ƒê·ªïi t·ª´ /files/base64 sang /file cho ph√π h·ª£p v·ªõi web
      return api.post(`${BASE_URL}/files/base64`, file, config);
    } catch (error) {
      console.error('Error uploading file:', error.message);
      throw error; // Rethrow ƒë·ªÉ component c√≥ th·ªÉ hi·ªÉn th·ªã l·ªói upload
    }
  },

  // sendFileMessage t·ª´ origin/chat-emoji - ƒë·ªÉ g·ª≠i ·∫£nh, video, t·ªáp ƒë√≠nh k√®m
  sendFileMessage: async (data, onProgress) => {
    try {
      const { file, conversationId, type = 'FILE' } = data;
      
      // √Ånh x·∫° c√°c lo·∫°i file chi ti·∫øt sang 3 lo·∫°i server ch·∫•p nh·∫≠n
      let serverType = 'FILE';
      if (type === 'IMAGE' || file.isImage) {
        serverType = 'IMAGE';
      } else if (type === 'VIDEO' || file.isVideo) {
        serverType = 'VIDEO';
      } else {
        // T·∫•t c·∫£ c√°c lo·∫°i kh√°c (PDF, DOC, EXCEL, vv.) ƒë·ªÅu l√† FILE
        serverType = 'FILE';
      }
      
      console.log('File ƒë∆∞·ª£c g·ª≠i v·ªõi type:', {
        originalType: type,
        mappedType: serverType
      });
      
      // T·∫°o FormData nh∆∞ tr∆∞·ªõc
      const formData = new FormData();
      formData.append('file', {
        uri: Platform.OS === 'ios' ? file.uri.replace('file://', '') : file.uri,
        type: file.type || 'application/octet-stream',
        name: file.name || `file-${Date.now()}`
      });
      
      // Quan tr·ªçng: S·ª≠ d·ª•ng serverType ƒë√£ √°nh x·∫° thay v√¨ type g·ªëc
      formData.append('type', serverType);
      formData.append('conversationId', conversationId);
      
      // URL c≈©ng s·ª≠ d·ª•ng serverType ƒë√£ √°nh x·∫° - s·ª≠a URL ƒë·ªÉ ph√π h·ª£p v·ªõi c·∫•u tr√∫c backend
      const url = `/messages/files?conversationId=${encodeURIComponent(conversationId)}&type=${encodeURIComponent(serverType)}`;
      
      console.log('Uploading to URL:', url);
      
      // C·∫•u h√¨nh request v·ªõi progress tracking
      const config = {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        onUploadProgress: (progressEvent) => {
          const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          console.log(`Upload progress: ${percentCompleted}%`);
          if (onProgress) {
            onProgress(percentCompleted);
          }
        }
      };

      // G·ªçi API v·ªõi URL ƒë√£ bao g·ªìm query params
      const response = await api.post(url, formData, config);
      console.log('File upload success:', response.data);
      return response;
    } catch (error) {
      console.error('Error in sendFileMessage:', error);
      // Log th√™m chi ti·∫øt
      if (error.response) {
        console.error('Server response:', error.response.status, error.response.data);
      }
      throw error;
    }
  },

  forwardMessage: async (messageId, targetConversationId, originalContent, messageType = 'TEXT') => {
    try {
      console.log(`Forwarding message ${messageId} to conversation ${targetConversationId}`);
      
      // Tr∆∞·ªõc h·∫øt, th·ª≠ s·ª≠ d·ª•ng API chia s·∫ª tin nh·∫Øn c√≥ s·∫µn n·∫øu c√≥ messageId
      if (messageId && messageId !== 'undefined' && messageId !== 'null') {
        try {
          console.log('Trying to use share message API with messageId:', messageId);
          const shareUrl = `${BASE_URL}/${messageId}/share/${targetConversationId}`;
          const shareResponse = await api.post(shareUrl);
          console.log('Successfully shared message using API:', shareResponse);
          return shareResponse;
        } catch (shareError) {
          console.error('Error using share API, falling back to manual forward:', shareError.message);
          // N·∫øu kh√¥ng th√†nh c√¥ng, ti·∫øp t·ª•c v·ªõi ph∆∞∆°ng th·ª©c th√¥ng th∆∞·ªùng
        }
      }
      
      // Thi·∫øt l·∫≠p prefix cho tin nh·∫Øn ƒë∆∞·ª£c chuy·ªÉn ti·∫øp
      let prefix = 'üì§ Tin nh·∫Øn ƒë∆∞·ª£c chuy·ªÉn ti·∫øp: \n';
      let actualContent = originalContent || '';
      
      // Kh√¥ng c√≥ API /messages/{id}/forward, n√™n ch√∫ng ta s·∫Ω:
      // 1. S·ª≠ d·ª•ng n·ªôi dung message g·ªëc ƒë∆∞·ª£c truy·ªÅn t·ª´ UI
      // 2. T·∫°o message m·ªõi v·ªõi n·ªôi dung ƒë√≥ ·ªü conversation ƒë√≠ch
      
      // X·ª≠ l√Ω kh√°c nhau t√πy theo lo·∫°i tin nh·∫Øn
      if (messageType === 'IMAGE') {
        console.log('ƒêang chuy·ªÉn ti·∫øp ·∫£nh:', originalContent);
        const formData = new FormData();
        formData.append('file', {
          uri: originalContent,
          type: 'image/jpeg',
          name: `forwarded-image-${Date.now()}.jpg`
        });
        formData.append('type', 'IMAGE');
        formData.append('conversationId', targetConversationId);
        formData.append('forwardedMessage', 'true'); // ƒê√°nh d·∫•u l√† tin nh·∫Øn ƒë∆∞·ª£c chuy·ªÉn ti·∫øp
        
        // S·ª≠a URL ƒë·ªÉ kh·ªõp v·ªõi format API c·ªßa backend
        const url = `/messages/files?conversationId=${encodeURIComponent(targetConversationId)}&type=IMAGE&forwardedMessage=true`;
        const config = {
          headers: {
            'Content-Type': 'multipart/form-data'
          }
        };
        
        console.log('Sending forwarded image message with URL:', url);
        return api.post(url, formData, config);
      }
      else if (messageType === 'VIDEO') {
        console.log('ƒêang chuy·ªÉn ti·∫øp video:', originalContent);
        const formData = new FormData();
        formData.append('file', {
          uri: originalContent,
          type: 'video/mp4',
          name: `forwarded-video-${Date.now()}.mp4`
        });
        formData.append('type', 'VIDEO');
        formData.append('conversationId', targetConversationId);
        formData.append('forwardedMessage', 'true');
        
        // S·ª≠a URL ƒë·ªÉ kh·ªõp v·ªõi format API c·ªßa backend
        const url = `/messages/files?conversationId=${encodeURIComponent(targetConversationId)}&type=VIDEO&forwardedMessage=true`;
        const config = {
          headers: {
            'Content-Type': 'multipart/form-data'
          }
        };
        
        console.log('Sending forwarded video message with URL:', url);
        return api.post(url, formData, config);
      } 
      else if (messageType === 'FILE') {
        console.log('ƒêang chuy·ªÉn ti·∫øp t·ªáp:', originalContent);
        const formData = new FormData();
        formData.append('file', {
          uri: originalContent,
          type: 'application/octet-stream',
          name: `forwarded-file-${Date.now()}`
        });
        formData.append('type', 'FILE');
        formData.append('conversationId', targetConversationId);
        formData.append('forwardedMessage', 'true');
        
        // S·ª≠a URL ƒë·ªÉ kh·ªõp v·ªõi format API c·ªßa backend
        const url = `/messages/files?conversationId=${encodeURIComponent(targetConversationId)}&type=FILE&forwardedMessage=true`;
        const config = {
          headers: {
            'Content-Type': 'multipart/form-data'
          }
        };
        
        console.log('Sending forwarded file message with URL:', url);
        return api.post(url, formData, config);
      } 
      else {
        // ƒê·ªëi v·ªõi tin nh·∫Øn TEXT th√¥ng th∆∞·ªùng
        if (!originalContent) {
          actualContent = 'N·ªôi dung tin nh·∫Øn kh√¥ng c√≥ s·∫µn';
          console.log('Kh√¥ng c√≥ n·ªôi dung g·ªëc, s·ª≠ d·ª•ng n·ªôi dung m·∫∑c ƒë·ªãnh');
        } else {
          console.log('S·ª≠ d·ª•ng n·ªôi dung g·ªëc ƒë∆∞·ª£c truy·ªÅn v√†o:', originalContent);
        }
        
        // T·∫°o message m·ªõi v·ªõi d·ªØ li·ªáu t·ª´ message g·ªëc v√† th√™m prefix
        const newMessage = {
          conversationId: targetConversationId,
          content: prefix + actualContent, // Th√™m prefix ƒë·ªÉ bi·∫øt ƒë√¢y l√† tin nh·∫Øn ƒë∆∞·ª£c chuy·ªÉn ti·∫øp
          type: 'TEXT', // Lu√¥n s·ª≠ d·ª•ng TEXT cho lo·∫°i tin nh·∫Øn th√¥ng th∆∞·ªùng
          forwardedMessage: true // Th√™m thu·ªôc t√≠nh ƒë√°nh d·∫•u l√† tin nh·∫Øn ƒë∆∞·ª£c chuy·ªÉn ti·∫øp
        };
        
        // Forward n·ªôi dung qua sendMessage API
        console.log('Sending forwarded text message:', newMessage);
        return messageApi.sendMessage(newMessage);
      }
    } catch (error) {
      console.error('Error forwarding message:', error.message);
      throw error;
    }
  },
  
  // Thu h·ªìi tin nh·∫Øn (Redo Message) - t∆∞∆°ng ƒë∆∞∆°ng v·ªõi redoMessage trong web
  recallMessage: (messageId) => {
    try {
      console.log('Recalling message for everyone:', messageId);
      // S·ª≠ d·ª•ng endpoint gi·ªëng phi√™n b·∫£n web - DELETE tr·ª±c ti·∫øp
      const url = `${BASE_URL}/${messageId}`;
      return api.delete(url);
    } catch (error) {
      console.error('Error recalling message:', error.message);
      throw error;
    }
  },
};

// S·ª≠ d·ª•ng export k√©p ƒë·ªÉ h·ªó tr·ª£ c·∫£ 2 c√°ch import ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c
// C√°ch 1: import { messageApi } from './messageApi'
// C√°ch 2: import messageApi from './messageApi'
export { messageApi };
export default messageApi;
